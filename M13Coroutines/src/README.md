## Задание 13. Корутины

### Что нужно сделать
Напишите программу, которая вычисляет n-е число из ряда Фибоначчи.
Вы уже сталкивались с задачей о числах Фибоначчи при изучении циклов. Теперь вам необходимо доработать существующий код
или написать программу заново с использованием корутин.

При возникновении сложностей обратитесь за помощью к куратору или прочтите блок «Советы и рекомендации».
Алгоритм выполнения задачи:

1. Создайте объект-синглтон Fibonacci.
2. В этом объекте создайте suspend функцию take. Функция принимает на вход число — номер в последовательности
   Фибоначчи — и возвращает рассчитанное число типа BigInteger. Для создания числа BigInteger используйте
   функцию-расширение [toBigInteger](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/to-big-integer.html).
3. Запустите две или более корутин в функции main. Используйте для этого функцию runBlocking и билдер launch. Внутри
   каждой корутины вызовите функцию take и выведите результат в консоль.
4. Рассчитайте несколько чисел Фибоначчи в порядке возрастания, затем в порядке убывания. Запустите программу несколько
   раз и проанализируйте порядок работы корутин.

Например:

По возрастанию: </br>
`launch { take (5) }` </br>
`launch { take (10) }` </br>
`launch { take (15) }` </br>

5. Сделайте suspend функцию take отменяемой. Используйте для этого функцию [yield](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html). Или функцию [currentCoroutineContext](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/current-coroutine-context.html) и
   его расширение [isActive](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html).
   Например:</br>
   `currentCoroutineContext().isActive`
   При необходимости выполнение функции должно прерываться. Точки прерывания определите самостоятельно, исходя из
   реализации вашей функции.
6. Запустите программу ещё несколько раз и вновь проанализируйте порядок работы корутин.
7. Отмените выполнение функции take при превышении какого-то времени. Используйте для этого функцию [withTimeout](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html).
   Например: </br>
   `withTimeout(3000) {`</br>
   `// some code` </br>
   `}` </br>
   запускает блок кода на выполнение и прерывает его выполнение при превышении 3-х секунд.

Подробнее про прерывание по таймауту можно прочитать [здесь](https://kotlinlang.org/docs/cancellation-and-timeouts.html#timeout).
Числа в цикле рассчитываются быстро, поэтому, чтобы отмена по таймауту была заметна, необходимо рассчитывать числа из
последовательности Фибоначчи с довольно большим порядковым номером. Использование цикла вместо рекурсии и BigInteger
вместо Long избавит от переполнения типа данных и переполнения стека.

8. При отмене по таймауту выбрасывается исключение TimeoutCancellationException. Обработайте это исключение и выведите в
   консоль сообщение о превышении времени вычисления.
9. Запустите ещё одну корутину, которая будет индикатором вычислений и выведет точки в консоль. Эта корутина должна
   работать до тех пор, пока идут вычисления всех ваших чисел Фибоначчи.

* По желанию: Добейтесь, чтобы вывод рассчитанных значений происходил после того, как будут рассчитаны все числа. Тем
  самым числа будут рассчитываться параллельно, но индикатор прогресса (точки) не будет прерываться сообщениями о
  рассчитанном числе.

Можно использовать для этого [Job](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/) и функцию [join](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html).

### Советы и рекомендации

Воспользуйтесь документацией:

- Общая информация по корутинам.
- Тип BigInteger.
- Функция yield.
- Функция currentCoroutineContext.
- Отмена корутин.
- Job.

**Что оценивается**
- Программа запускается, работает корректно и выводит всю необходимую информацию.
- Выполнены все пункты обязательной части задания.
- Функции соответствуют принципам чёрного ящика, выполняют атомарные операции и независимы друг от друга.